mutate( rank_knowledge = row_number() )
hetConNoDat <- hetConNoDat %>%
arrange( culture, knowledge ) %>%
mutate( rank_knowledge = row_number() )
# ================================================================== #
# Plotting results ----
datToPlot <- list( noConAgreementDat, ConAgreementDat, HetConAgreementDat, HetConNoAgreementDat )
titlesPlot <- c(
"Noncoherent",
"Monocentric",
"Multicentric",
"Multicentric"
)
plotList <- list()
for( i in 1: length( datToPlot ) ) {
plotList[[i]] <- ggplot( data = datToPlot[[i]], aes( Var2, Var1, fill = value ) ) +
geom_tile( color = "white" ) +
scale_fill_gradient2( low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c( -1,1 ), space = "Lab",
name="Agreement" ) +
theme_minimal() +
coord_fixed() +
theme(
axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x=element_blank(), axis.text.y=element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal") +
guides(fill = guide_colorbar( barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5) ) +
ggtitle( titlesPlot[i] )
#print( plotList[[i]] )
}
grid.arrange(
plotList[[1]],plotList[[2]], plotList[[3]], plotList[[4]],
nrow = 2, ncol = 2
)
# ================================================================== #
# Plots ----
# Create the scatterplots
datToPlot2 <- list( noConDat, conDat, hetConDat, hetConNoDat )
titlesPlot2 <- c(
"Noncoherent",
"Monocentric",
"Multicentric",
"Multicentric"
)
plotList2 <- list()
for( i in 1: length( datToPlot2 ) ) {
plotList2[[i]] <- ggplot( datToPlot2[[i]],
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( culture ) ) ) +
geom_point() +
labs( title = titlesPlot2[[i]],
x = "Respondents",
y = "Knowledge") +
theme_minimal() +
theme( legend.position = "none",
axis.text.x = element_blank(),
plot.margin = unit( c( 1, 1, 1, 1 ), "cm" ),
plot.title = element_text( hjust = 0.5 ) ) +
guides( color = guide_legend( title = "Group" ) ) +
scale_y_continuous( limits = c( 0, 1 ) )
#print( hetConNoPlot )
}
# ================================================================== #
# Plots ----
# Create the scatterplots
datToPlot2 <- list( noConDat, conDat, hetConDat, hetConNoDat )
titlesPlot2 <- c(
"Noncoherent",
"Monocentric",
"Multicentric",
"Multicentric"
)
plotList2 <- list()
for( i in 1: length( datToPlot2 ) ) {
plotList2[[i]] <- ggplot( datToPlot2[[i]],
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( culture ) ) ) +
geom_point() +
labs( title = titlesPlot2[[i]],
x = "Respondents",
y = "Knowledge") +
theme_minimal() +
theme( legend.position = "none",
axis.text.x = element_blank(),
plot.margin = unit( c( 1, 1, 1, 1 ), "cm" ),
plot.title = element_text( hjust = 0.5 ) ) +
guides( color = guide_legend( title = "Group" ) ) +
scale_y_continuous( limits = c( 0, 1 ) )
#print( hetConNoPlot )
}
grid.arrange(
plotList2[[1]],plotList2[[2]], plotList2[[3]], plotList2[[4]],
nrow = 2, ncol = 2
)
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file assess model fit for models estimated
# in the trust-culture-heterogeneity-estimation.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )   # for the cultural consensus models
library( here )      # for calling local directory
library( dplyr )     # for working with the data
library( reshape2 )  # for reworking the data
library( ggplot2 )   # for plotting the agreement matrix
library( gridExtra ) # for plotting grids
library( grid )      # for plotting titles on the grid
# ================================================================== #
# load the trust variables ----
# load the data
trust.vars <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
# ================================================================== #
# create the agreement matrix and export it ----
# Function to create the agreement matrix.
# The equation comes from pg. 65 of Purzycki, B. G., & Jamieson-Lane, A. (2016).
# AnthroTools. Cross-Cultural Research, 51(1), 51-74. doi:10.1177/1069397116680352.
DiscountedAgreementMatrix <-
function( response.mat, n.responses ){
discounted.matrix= matrix( 0, nrow( response.mat ),nrow( response.mat ) )
for( i in 1:nrow( discounted.matrix ) ){
for( j in 1:ncol( discounted.matrix ) ){
discounted.matrix[i,j] <- mean( response.mat[i,] == response.mat[j,], na.rm = TRUE ) # Create the average number of items i and j agree on.
}
}
discounted.matrix <- ( discounted.matrix*n.responses -1 ) / (n.responses-1 ) # Correct the average agreement for guessing.
diag( discounted.matrix ) <- 0 # set the diagonal to zero.
discounted.matrix[is.finite(discounted.matrix) == FALSE] <- 0 # adjust Inf values to zero (if any).
return( discounted.matrix )
}
trust.agreement <- DiscountedAgreementMatrix( trust.vars[,-1], 2 )
mean( trust.agreement )
dat.for.plot <- function( cormat ){
dd <- as.dist( ( 1-cormat )/2 ) # Use correlation between variables as distance.
hc <- hclust( dd )
cormat <-cormat[hc$order, hc$order]
cormat[lower.tri( cormat )] <- NA # set the lower part of the triangle as missing (redundant information).
cor.dat <- melt( cormat, na.rm = TRUE ) # create the dataframe.
return( cor.dat )
}
# assign the agreement matrix to the object to plot.
trust.agreement.dat <- dat.for.plot( trust.agreement )
# Plot for trust.
ggheatmap.T <- ggplot( data = trust.agreement.dat, aes( Var2, Var1, fill = value ) ) +
geom_tile( color = "white" ) +
scale_fill_gradient2( low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c( -1,1 ), space = "Lab",
name="Agreement" ) +
theme_minimal() +
coord_fixed() +
theme(
axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x=element_blank(), axis.text.y=element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal") +
guides(fill = guide_colorbar( barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5) ) +
ggtitle( "Plot of Agreement for Trust Items" )
print( ggheatmap.T )
trust.plot   <- cctscree( trust.vars[,-1], polych = FALSE )
# ================================================================== #
# Load the estimated models ----
# load the object and set the name
trust.fit.2.diff <- load( here( "trust-culture-rodeo/trust.fit.2.diff.Rdata" ) )
trust.fit.2.diff <- cctfit
# plot the posterior predictive model checks
cctppc( trust.fit.2.diff )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file analyses the results from the
# trust-culture-heterogeneity-estimation.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )  # for the cultural consensus models
library( here )     # for calling local directory
library( dplyr )    # for working with the data
library( reshape2 ) # for reworking the data
library( ggplot2 )  # for plotting
library( psych )    # for reliability analysis
# ================================================================== #
# load the trust variables ----
# load the data
trust.vars <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
# ================================================================== #
# Load the estimated models ----
# load the object and set the name
trust.fit.2.diff <- load( here( "trust-culture-rodeo/trust.fit.2.diff.Rdata" ) )
trust.fit.2.diff <- cctfit
# ================================================================== #
# Build Figure 4 of cultural knowledge ----
# build the object to plot
knowledgeDat <- data.frame(
assignmentID = trust.fit.2.diff$subj[,1],
culture      = trust.fit.2.diff$subj[,2],
knowledge    = trust.fit.2.diff$subj[,3]
)
# recode the cultural model assignment to make group 2 group 1
# and group 1 group 2 (this is for ease of interpretation)
cultureRecoded <- knowledgeDat$culture
cultureRecoded[ knowledgeDat$culture == 2 ] <- 0
cultureRecoded[ knowledgeDat$culture == 1 ] <- 2
cultureRecoded[ knowledgeDat$culture == 2 ] <- 1
knowledgeDat$cultureRecoded <- cultureRecoded
# Calculate mean for each group
culturalMeansSds <- knowledgeDat %>%
group_by( cultureRecoded ) %>%
summarise( mean_knowledge = round( mean( knowledge ), 2 ),
sd_knowledge = round( sd( knowledge ), 2 ) )
# Add a new variable that ranks responses within each group
knowledgeDat <- knowledgeDat %>%
arrange( cultureRecoded, knowledge ) %>%
mutate( rank_knowledge = row_number() )
# Create the scatterplot
knowledgePlot <- ggplot( knowledgeDat,
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( cultureRecoded ) ) ) +
geom_point() +
labs( title = "Scatterplot of Respondent Knowledge by Relationship Model",
x = "Respondents",
y = "Knowledge") +
geom_hline( data = culturalMeansSds,
aes( yintercept = mean_knowledge, colour = as.factor( cultureRecoded ) ) ) +
theme_minimal() +
theme( legend.position = "top",
axis.text.x = element_blank() ) +
guides( color = guide_legend( title = "Relationship Model: " ) )
print( knowledgePlot )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file analyses the results from the
# trust-culture-heterogeneity-estimation.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )  # for the cultural consensus models
library( here )     # for calling local directory
library( dplyr )    # for working with the data
library( reshape2 ) # for reworking the data
library( ggplot2 )  # for plotting
library( psych )    # for reliability analysis
# ================================================================== #
# load the trust variables ----
# load the data
trust.vars <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
# ================================================================== #
# Load the estimated models ----
# load the object and set the name
trust.fit.2.diff <- load( here( "trust-culture-rodeo/trust.fit.2.diff.Rdata" ) )
trust.fit.2.diff <- cctfit
# ================================================================== #
# Build Figure 4 of cultural knowledge ----
# build the object to plot
knowledgeDat <- data.frame(
assignmentID = trust.fit.2.diff$subj[,1],
culture      = trust.fit.2.diff$subj[,2],
knowledge    = trust.fit.2.diff$subj[,3]
)
# recode the cultural model assignment to make group 2 group 1
# and group 1 group 2 (this is for ease of interpretation)
cultureRecoded <- knowledgeDat$culture
cultureRecoded[ knowledgeDat$culture == 2 ] <- 0
cultureRecoded[ knowledgeDat$culture == 1 ] <- 2
cultureRecoded[ knowledgeDat$culture == 2 ] <- 1
knowledgeDat$cultureRecoded <- cultureRecoded
# Calculate mean for each group
culturalMeansSds <- knowledgeDat %>%
group_by( cultureRecoded ) %>%
summarise( mean_knowledge = round( mean( knowledge ), 2 ),
sd_knowledge = round( sd( knowledge ), 2 ) )
# Add a new variable that ranks responses within each group
knowledgeDat <- knowledgeDat %>%
arrange( cultureRecoded, knowledge ) %>%
mutate( rank_knowledge = row_number() )
# Create the scatterplot
knowledgePlot <- ggplot( knowledgeDat,
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( cultureRecoded ) ) ) +
geom_point() +
labs( #title = "Scatterplot of Respondent Knowledge by Relationship Model",
x = "Respondents",
y = "Knowledge") +
geom_hline( data = culturalMeansSds,
aes( yintercept = mean_knowledge, colour = as.factor( cultureRecoded ) ) ) +
theme_minimal() +
theme( legend.position = "top",
axis.text.x = element_blank() ) +
guides( color = guide_legend( title = "Relationship Model: " ) )
print( knowledgePlot )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file assess model fit for models estimated
# in the trust-culture-heterogeneity-analysis.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )  # for the cultural consensus models
library( here )     # for calling local directory
library( dplyr )    # for working with the data
library( reshape2 ) # for reworking the data
library( ggplot2 )  # for plotting the agreement matrix
# ================================================================== #
# Load the estimated models ----
## 1 model (no item difficulty)
# load the object and set the name
trust.fit.1 <- load( here( "trust-culture-rodeo/trust.fit.1.Rdata" ) )
trust.fit.1 <- cctfit
cctppc( trust.fit.1 )
# load the object and set the name
trust.fit.2 <- load( here( "trust-culture-rodeo/trust.fit.2.Rdata" ) )
trust.fit.2 <- cctfit
cctppc( trust.fit.2 )
# load the object and set the name
trust.fit.3 <- load( here( "trust-culture-rodeo/trust.fit.3.Rdata" ) )
trust.fit.3 <- cctfit
cctppc( trust.fit.3 )
# load the object and set the name
trust.fit.4 <- load( here( "trust-culture-rodeo/trust.fit.4.Rdata" ) )
trust.fit.4 <- cctfit
cctppc( trust.fit.4 )
# load the object and set the name
trust.fit.5 <- load( here( "trust-culture-rodeo/trust.fit.4.Rdata" ) )
trust.fit.5 <- cctfit
cctppc( trust.fit.5 )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# DOCUMENT!!!
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries
library( dplyr ) # for working with the data
library( here )  # to call local directory
# ================================================================== #
# load the data
dat <- readRDS( file = here( "PR-interviewer-comparison-rodeo/trust.rhps.cntrls.vars.data.rds" ) )
# coerce to a data frame
dat <- as.data.frame( dat )
# ================================================================== #
# Create the function to build the set of t.tests
t.test.data <- function( dat.to.use, vars.to.use, group.var, alpha = 0.05 ){
# Create the objects to assign values
tests <- as.list( NULL )
values <- NA
pval <- NA
uci <- NA
lci <- NA
# Perform the tests
for( i in 1: ncol( vars.to.use ) ){
tests[[i]] <-
t.test( vars.to.use[[i]] ~ group.var, data = dat.to.use )
}
# Extract the values
for( i in 1: length( tests ) ){
values[i] <- round( ( tests[[i]]$estimate[1] - tests[[i]]$estimate[2] ), 3 )
pval[i]   <- round( tests[[i]]$p.value, 3 )
lci[i]    <- round( tests[[i]]$conf.int[1], 3 )
uci[i]    <- round( tests[[i]]$conf.int[2], 3 )
}
# Create the bonferroni corrected pvalues
bonf.pval <- round( alpha / length( tests ), 3 )
# Create reject/fail to reject
reject <- NULL
reject <- pval < bonf.pval
# Build the data object
results <- cbind( values, pval, bonf.pval, reject, lci, uci )
colnames( results ) <- c( "tvalue", "pvalue", "Bonf.Pvalue", "Reject?", "LCI", "UCI" )
rownames( results ) <- names( vars.to.use )
return( as.data.frame( results ) )
}
# ================================================================== #
# Create the function to plot the results
plot.ttests <- function( t.results, the.title ){
point    <- t.results$tvalue
upper.ci <- t.results$UCI
lower.ci <- t.results$LCI
x.ax <- seq( 1, dim( t.results )[1], length.out = dim( t.results )[1] )
y.ax <- seq(
min( c( upper.ci,lower.ci ) ),
max( c( upper.ci,lower.ci ) ),
length.out= dim( t.results )[1]
)
plot(x.ax,
y.ax,
type = "n",
ylab = "t-test coefficient w/ 95% CI",
xlab = "",
xaxt = "n"
)
points( x.ax, point )
segments(x.ax, upper.ci, x.ax, lower.ci)
abline( h = 0, lty = 2 )
axis( side = 1, at = x.ax, las = 3, labels = custom_labels )
title( the.title )
}
# ================================================================== #
# Check balance in covariates among those who were randomized
# Get the data you want to compare
balance.dat <- dat %>%
select(
id, Interviewer, Randomize,
Log_Age, White, Black, Hispanic,
Education, Single, Children, First_Timer,
Time_In, Sentence_Length, Lifer
)
# keep 158 cases, table(balance.dat$Randomize == 1)
randomized.dat <- balance.dat[balance.dat$Randomize == 1,]
# table based on who was interviewed
table( randomized.dat$Interviewer )
# Create the variables to perform the tests on
randomized.vars.to.use <- randomized.dat %>%
select( -c( id, Interviewer, Randomize ) )
# Create vector of names for the plot
custom_labels <- c(
"Age\n (Logged)", "White", "Black", "Hispanic", "Years of\n Education", "Single", "Has\n Children",
"First Time\n in Prison", "Time In\n Prison", "Sentence\n Length", "Lifer"
)
# Create the object of t-test results
randomized.t.results <- t.test.data(
randomized.dat, randomized.vars.to.use, randomized.dat$Interviewer
)
plot.ttests( randomized.t.results, "Figure #: Balance among \nRandomized Interviewees (n = 158)" )
dat <- as.data.frame(
response = c(
rep( 1, 58 ),
rep( 0, 80-58 ),
rep( 1, 40 ),
rep( 0, 78-40 ) ),
interviewer = c(
rep( 1, 80 ),
rep( 0, 78 )
)
)
c(
rep( 1, 58 ),
rep( 0, 80-58 ),
rep( 1, 40 ),
rep( 0, 78-40 ) )
c(
rep( 1, 80 ),
rep( 0, 78 )
)
dat <- as.data.frame(
response = c(
rep( 1, 58 ),
rep( 0, 80-58 ),
rep( 1, 40 ),
rep( 0, 78-40 ) ),
interviewer = c(
rep( 1, 80 ),
rep( 0, 78 )
)
)
dat <- as.dataframe(
response = c(
rep( 1, 58 ),
rep( 0, 80-58 ),
rep( 1, 40 ),
rep( 0, 78-40 ) ),
interviewer = c(
rep( 1, 80 ),
rep( 0, 78 )
)
)
response <- c(
rep( 1, 58 ),
rep( 0, 80-58 ),
rep( 1, 40 ),
rep( 0, 78-40 ) ),
response <- c(
rep( 1, 58 ),
rep( 0, 80-58 ),
rep( 1, 40 ),
rep( 0, 78-40 ) )
interviewer <- c(
rep( 1, 80 ),
rep( 0, 78 )
)
response
interviewer
dat <- as.data.frame(r = response, i = interviewer)
58/80
