print( knowledgePlot )
dev.off()
# ================================================================== #
# Cultural model assignment and knowledge as a predictor ----
# get the relational health and psychological safety variables
rhpsDat <- readRDS( file = here( "trust-culture-rodeo/trust.rhps.cntrls.vars.data.rds" ) )
# merge the cultural model data with the relational health and psychological safety data
match.id <- data.frame(
ID = trust.vars[,1]
)
modelDat <- inner_join( match.id, rhpsDat )
knowledgeDat <- knowledgeDat %>%
arrange( assignmentID )
modelDat <- left_join( knowledgeDat, modelDat )
names(modelDat)
trust.vars
head(trust.vars)
trust.vars.temp <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
rhps.vars.temp  <- readRDS( file = here( "trust-culture-rodeo/trust.rhps.cntrls.vars.data.rds" ) )
trust.vars.temp
head(trust.vars.temp)
dim(trust.vars.temp)
dim(trust.vars.temp[,-1])
trust.vars.temp <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
rhps.vars.temp  <- readRDS( file = here( "trust-culture-rodeo/trust.rhps.cntrls.vars.data.rds" ) )
round( apply( trust.vars.temp[,-1], 2, mean ), 2 )
round( apply( trust.vars.temp[,-1], 2, sd ), 2 )
rhps.vars.temp
head(rhps.vars.temp)
round( mean( rhps.vars.temp$rh ), 2 )
round( mean( rhps.vars.temp$rh ), 2 )
round( mean( rhps.vars.temp$ps ), 2 )
round( mean( rhps.vars.temp$age ), 2 )
round( mean( rhps.vars.temp$white ), 2 )
round( mean( rhps.vars.temp$black ), 2 )
round( mean( rhps.vars.temp$hispanic ), 2 )
round( mean( rhps.vars.temp$timein_yrs ), 2 )
round( mean( rhps.vars.temp$interviewer ), 2 )
round( mean( rhps.vars.temp$randomized ), 2 )
round( sd( rhps.vars.temp$rh ), 2 )
round( sd( rhps.vars.temp$ps ), 2 )
round( sd( rhps.vars.temp$age ), 2 )
round( sd( rhps.vars.temp$white ), 2 )
round( sd( rhps.vars.temp$black ), 2 )
round( sd( rhps.vars.temp$hispanic ), 2 )
round( sd( rhps.vars.temp$timein_yrs ), 2 )
round( sd( rhps.vars.temp$interviewer ), 2 )
round( sd( rhps.vars.temp$randomized ), 2 )
round( sd( rhps.vars.temp$rh ), 2 )
round( sd( rhps.vars.temp$ps ), 2 )
round( sd( rhps.vars.temp$age ), 2 )
round( sd( rhps.vars.temp$white ), 2 )
round( sd( rhps.vars.temp$black ), 2 )
round( sd( rhps.vars.temp$hispanic ), 2 )
round( sd( rhps.vars.temp$timein_yrs ), 2 )
round( sd( rhps.vars.temp$interviewer ), 2 )
round( sd( rhps.vars.temp$randomized ), 2 )
####CLEAN ALL THIS UP!!!!
# Clear the workspace
rm( list = ls() )
library( here )      # for the directory
library( dplyr )     # for working with the data
library( reshape2 )  # for reworking the data
library( ggplot2 )   # for plotting
library( gridExtra ) # for plotting grids
library( grid )      # for plotting titles on the grid
# set seed to reproduce same objects
set.seed( 2468 )
# ================================================================== #
# Function to create the agreement matrix ----
# The equation comes from pg. 65 of Purzycki, B. G., & Jamieson-Lane, A. (2016). AnthroTools. Cross-Cultural Research, 51(1), 51-74. doi:10.1177/1069397116680352.
DiscountedAgreementMatrix <-
function( response.mat, n.responses ){
discounted.matrix= matrix( 0, nrow( response.mat ),nrow( response.mat ) )
for( i in 1:nrow( discounted.matrix ) ){
for( j in 1:ncol( discounted.matrix ) ){
discounted.matrix[i,j] <- mean( response.mat[i,] == response.mat[j,], na.rm = TRUE ) # Create the average number of items i and j agree on
}
}
discounted.matrix <- ( discounted.matrix*n.responses -1 ) / (n.responses-1 ) # Correct the average agreement for guessing
diag( discounted.matrix ) <- 0 # set the diagonal to zero
discounted.matrix[is.finite(discounted.matrix) == FALSE] <- 0 # adjust Inf values to zero (if any)
return( discounted.matrix )
}
# Create data for the plot.
dat.for.plot <- function( cormat ){
dd <- as.dist( ( 1-cormat )/2 ) # Use correlation between variables as distance
hc <- hclust( dd )
cormat <-cormat[hc$order, hc$order]
cormat[lower.tri( cormat )] <- NA # set the lower part of the triangle as missing (redundant information)
cor.dat <- melt( cormat, na.rm = TRUE ) # create the dataframe
return( cor.dat )
}
# ================================================================== #
# Create the data objects ----
nResp <- 100
nVars <- 50
# build the function to create the response matrices
build.responses <- function( nResp, nVars, probValue, nresponses ){
# create the blank object
Response <- matrix( NA, nrow = nResp, ncol = nVars )
# loop through to create the responses
for( i in 1: nVars ){
Response[,i] <- rbinom( nResp, 1, prob = probValue )
}
# create the agreement matrix
Agreement <- DiscountedAgreementMatrix( Response, nresponses )
# Assign the agreement matrix to the object to plot
AgreementDat <- dat.for.plot( Agreement )
# return the agreement data as a data frame to plot
return( AgreementDat )
}
noConAgreementDat <- build.responses( nResp, nVars, probValue = 0.5, nresponses = 2 )
ConAgreementDat   <- build.responses( nResp, nVars, probValue = 0.8, nresponses = 2 )
# build the function to create the response matrices
build.het.responses <- function( nResp, nVars, probValue1, probValue2, nresponses ){
# create the blank object
Response <- matrix( NA, nrow = nResp, ncol = nVars )
# loop through to create the responses
for( i in 1: nResp / 2 ){
Response[i,] <- rbinom( nResp / 2, 1, prob = probValue1 )
Response[i + nResp / 2,] <- rbinom( nResp / 2, 1, prob = probValue2 )
}
# create the agreement matrix
Agreement <- DiscountedAgreementMatrix( Response, nresponses )
# Assign the agreement matrix to the object to plot
AgreementDat <- dat.for.plot( Agreement )
# return the agreement data as a data frame to plot
return( AgreementDat )
}
HetConAgreementDat   <- build.het.responses( nResp, nVars, probValue1 = 0.8, probValue2 = 0.2, nresponses = 2 )
HetConNoAgreementDat <- build.het.responses( nResp, nVars, probValue1 = 0.8, probValue2 = 0.5, nresponses = 2 )
# ================================================================== #
# Create the data objects ----
n <- 100
noConDat <- data.frame(
knowledge = runif( n = n, min = .00 , max = 0.30 ),
culture = rep( 1, n )
)
conDat <- data.frame(
knowledge = runif( n = n, min = .80 , max = 0.99 ),
culture = rep( 1, n )
)
hetConDat <- data.frame(
knowledge = c( runif( n = n/2, min = .80 , max = 0.99 ), runif( n = n/2, min = .80 , max = 0.99 ) ) ,
culture = c( rep( 1, n/2 ), rep( 2, n/2 ) )
)
hetConNoDat <- data.frame(
knowledge = c( runif( n = n/2, min = .80 , max = 0.99 ), runif( n = n/2, min = .00 , max = 0.30 ) ) ,
culture = c( rep( 1, n/2 ), rep( 2, n/2 ) )
)
# Add a new variable that ranks responses within each group
noConDat <- noConDat %>%
arrange( culture, knowledge ) %>%
mutate( rank_knowledge = row_number() )
conDat <- conDat %>%
arrange( culture, knowledge ) %>%
mutate( rank_knowledge = row_number() )
hetConDat <- hetConDat %>%
arrange( culture, knowledge ) %>%
mutate( rank_knowledge = row_number() )
hetConNoDat <- hetConNoDat %>%
arrange( culture, knowledge ) %>%
mutate( rank_knowledge = row_number() )
# ================================================================== #
# Plotting results ----
datToPlot <- list( noConAgreementDat, ConAgreementDat, HetConAgreementDat, HetConNoAgreementDat )
titlesPlot <- c(
"Noncoherent",
"Monocentric",
"Multicentric",
"Multicentric"
)
plotList <- list()
for( i in 1: length( datToPlot ) ) {
plotList[[i]] <- ggplot( data = datToPlot[[i]], aes( Var2, Var1, fill = value ) ) +
geom_tile( color = "white" ) +
scale_fill_gradient2( low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c( -1,1 ), space = "Lab",
name="Agreement" ) +
theme_minimal() +
coord_fixed() +
theme(
axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x=element_blank(), axis.text.y=element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal") +
guides(fill = guide_colorbar( barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5) ) +
ggtitle( titlesPlot[i] )
#print( plotList[[i]] )
}
grid.arrange(
plotList[[1]],plotList[[2]], plotList[[3]], plotList[[4]],
nrow = 2, ncol = 2
)
# ================================================================== #
# Plots ----
# Create the scatterplots
datToPlot2 <- list( noConDat, conDat, hetConDat, hetConNoDat )
titlesPlot2 <- c(
"Noncoherent",
"Monocentric",
"Multicentric",
"Multicentric"
)
plotList2 <- list()
for( i in 1: length( datToPlot2 ) ) {
plotList2[[i]] <- ggplot( datToPlot2[[i]],
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( culture ) ) ) +
geom_point() +
labs( title = titlesPlot2[[i]],
x = "Respondents",
y = "Knowledge") +
theme_minimal() +
theme( legend.position = "none",
axis.text.x = element_blank(),
plot.margin = unit( c( 1, 1, 1, 1 ), "cm" ),
plot.title = element_text( hjust = 0.5 ) ) +
guides( color = guide_legend( title = "Group" ) ) +
scale_y_continuous( limits = c( 0, 1 ) )
#print( hetConNoPlot )
}
# ================================================================== #
# Plots ----
# Create the scatterplots
datToPlot2 <- list( noConDat, conDat, hetConDat, hetConNoDat )
titlesPlot2 <- c(
"Noncoherent",
"Monocentric",
"Multicentric",
"Multicentric"
)
plotList2 <- list()
for( i in 1: length( datToPlot2 ) ) {
plotList2[[i]] <- ggplot( datToPlot2[[i]],
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( culture ) ) ) +
geom_point() +
labs( title = titlesPlot2[[i]],
x = "Respondents",
y = "Knowledge") +
theme_minimal() +
theme( legend.position = "none",
axis.text.x = element_blank(),
plot.margin = unit( c( 1, 1, 1, 1 ), "cm" ),
plot.title = element_text( hjust = 0.5 ) ) +
guides( color = guide_legend( title = "Group" ) ) +
scale_y_continuous( limits = c( 0, 1 ) )
#print( hetConNoPlot )
}
grid.arrange(
plotList2[[1]],plotList2[[2]], plotList2[[3]], plotList2[[4]],
nrow = 2, ncol = 2
)
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file assess model fit for models estimated
# in the trust-culture-heterogeneity-estimation.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )   # for the cultural consensus models
library( here )      # for calling local directory
library( dplyr )     # for working with the data
library( reshape2 )  # for reworking the data
library( ggplot2 )   # for plotting the agreement matrix
library( gridExtra ) # for plotting grids
library( grid )      # for plotting titles on the grid
# ================================================================== #
# load the trust variables ----
# load the data
trust.vars <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
# ================================================================== #
# create the agreement matrix and export it ----
# Function to create the agreement matrix.
# The equation comes from pg. 65 of Purzycki, B. G., & Jamieson-Lane, A. (2016).
# AnthroTools. Cross-Cultural Research, 51(1), 51-74. doi:10.1177/1069397116680352.
DiscountedAgreementMatrix <-
function( response.mat, n.responses ){
discounted.matrix= matrix( 0, nrow( response.mat ),nrow( response.mat ) )
for( i in 1:nrow( discounted.matrix ) ){
for( j in 1:ncol( discounted.matrix ) ){
discounted.matrix[i,j] <- mean( response.mat[i,] == response.mat[j,], na.rm = TRUE ) # Create the average number of items i and j agree on.
}
}
discounted.matrix <- ( discounted.matrix*n.responses -1 ) / (n.responses-1 ) # Correct the average agreement for guessing.
diag( discounted.matrix ) <- 0 # set the diagonal to zero.
discounted.matrix[is.finite(discounted.matrix) == FALSE] <- 0 # adjust Inf values to zero (if any).
return( discounted.matrix )
}
trust.agreement <- DiscountedAgreementMatrix( trust.vars[,-1], 2 )
mean( trust.agreement )
dat.for.plot <- function( cormat ){
dd <- as.dist( ( 1-cormat )/2 ) # Use correlation between variables as distance.
hc <- hclust( dd )
cormat <-cormat[hc$order, hc$order]
cormat[lower.tri( cormat )] <- NA # set the lower part of the triangle as missing (redundant information).
cor.dat <- melt( cormat, na.rm = TRUE ) # create the dataframe.
return( cor.dat )
}
# assign the agreement matrix to the object to plot.
trust.agreement.dat <- dat.for.plot( trust.agreement )
# Plot for trust.
ggheatmap.T <- ggplot( data = trust.agreement.dat, aes( Var2, Var1, fill = value ) ) +
geom_tile( color = "white" ) +
scale_fill_gradient2( low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c( -1,1 ), space = "Lab",
name="Agreement" ) +
theme_minimal() +
coord_fixed() +
theme(
axis.title.x = element_blank(), axis.title.y = element_blank(),
axis.text.x=element_blank(), axis.text.y=element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal") +
guides(fill = guide_colorbar( barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5) ) +
ggtitle( "Plot of Agreement for Trust Items" )
print( ggheatmap.T )
trust.plot   <- cctscree( trust.vars[,-1], polych = FALSE )
# ================================================================== #
# Load the estimated models ----
# load the object and set the name
trust.fit.2.diff <- load( here( "trust-culture-rodeo/trust.fit.2.diff.Rdata" ) )
trust.fit.2.diff <- cctfit
# plot the posterior predictive model checks
cctppc( trust.fit.2.diff )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file analyses the results from the
# trust-culture-heterogeneity-estimation.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )  # for the cultural consensus models
library( here )     # for calling local directory
library( dplyr )    # for working with the data
library( reshape2 ) # for reworking the data
library( ggplot2 )  # for plotting
library( psych )    # for reliability analysis
# ================================================================== #
# load the trust variables ----
# load the data
trust.vars <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
# ================================================================== #
# Load the estimated models ----
# load the object and set the name
trust.fit.2.diff <- load( here( "trust-culture-rodeo/trust.fit.2.diff.Rdata" ) )
trust.fit.2.diff <- cctfit
# ================================================================== #
# Build Figure 4 of cultural knowledge ----
# build the object to plot
knowledgeDat <- data.frame(
assignmentID = trust.fit.2.diff$subj[,1],
culture      = trust.fit.2.diff$subj[,2],
knowledge    = trust.fit.2.diff$subj[,3]
)
# recode the cultural model assignment to make group 2 group 1
# and group 1 group 2 (this is for ease of interpretation)
cultureRecoded <- knowledgeDat$culture
cultureRecoded[ knowledgeDat$culture == 2 ] <- 0
cultureRecoded[ knowledgeDat$culture == 1 ] <- 2
cultureRecoded[ knowledgeDat$culture == 2 ] <- 1
knowledgeDat$cultureRecoded <- cultureRecoded
# Calculate mean for each group
culturalMeansSds <- knowledgeDat %>%
group_by( cultureRecoded ) %>%
summarise( mean_knowledge = round( mean( knowledge ), 2 ),
sd_knowledge = round( sd( knowledge ), 2 ) )
# Add a new variable that ranks responses within each group
knowledgeDat <- knowledgeDat %>%
arrange( cultureRecoded, knowledge ) %>%
mutate( rank_knowledge = row_number() )
# Create the scatterplot
knowledgePlot <- ggplot( knowledgeDat,
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( cultureRecoded ) ) ) +
geom_point() +
labs( title = "Scatterplot of Respondent Knowledge by Relationship Model",
x = "Respondents",
y = "Knowledge") +
geom_hline( data = culturalMeansSds,
aes( yintercept = mean_knowledge, colour = as.factor( cultureRecoded ) ) ) +
theme_minimal() +
theme( legend.position = "top",
axis.text.x = element_blank() ) +
guides( color = guide_legend( title = "Relationship Model: " ) )
print( knowledgePlot )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file analyses the results from the
# trust-culture-heterogeneity-estimation.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )  # for the cultural consensus models
library( here )     # for calling local directory
library( dplyr )    # for working with the data
library( reshape2 ) # for reworking the data
library( ggplot2 )  # for plotting
library( psych )    # for reliability analysis
# ================================================================== #
# load the trust variables ----
# load the data
trust.vars <- readRDS( file = here( "trust-culture-rodeo/trust.fit.data.rds" ) )
# ================================================================== #
# Load the estimated models ----
# load the object and set the name
trust.fit.2.diff <- load( here( "trust-culture-rodeo/trust.fit.2.diff.Rdata" ) )
trust.fit.2.diff <- cctfit
# ================================================================== #
# Build Figure 4 of cultural knowledge ----
# build the object to plot
knowledgeDat <- data.frame(
assignmentID = trust.fit.2.diff$subj[,1],
culture      = trust.fit.2.diff$subj[,2],
knowledge    = trust.fit.2.diff$subj[,3]
)
# recode the cultural model assignment to make group 2 group 1
# and group 1 group 2 (this is for ease of interpretation)
cultureRecoded <- knowledgeDat$culture
cultureRecoded[ knowledgeDat$culture == 2 ] <- 0
cultureRecoded[ knowledgeDat$culture == 1 ] <- 2
cultureRecoded[ knowledgeDat$culture == 2 ] <- 1
knowledgeDat$cultureRecoded <- cultureRecoded
# Calculate mean for each group
culturalMeansSds <- knowledgeDat %>%
group_by( cultureRecoded ) %>%
summarise( mean_knowledge = round( mean( knowledge ), 2 ),
sd_knowledge = round( sd( knowledge ), 2 ) )
# Add a new variable that ranks responses within each group
knowledgeDat <- knowledgeDat %>%
arrange( cultureRecoded, knowledge ) %>%
mutate( rank_knowledge = row_number() )
# Create the scatterplot
knowledgePlot <- ggplot( knowledgeDat,
aes( x = rank_knowledge,
y = knowledge,
color = as.factor( cultureRecoded ) ) ) +
geom_point() +
labs( #title = "Scatterplot of Respondent Knowledge by Relationship Model",
x = "Respondents",
y = "Knowledge") +
geom_hline( data = culturalMeansSds,
aes( yintercept = mean_knowledge, colour = as.factor( cultureRecoded ) ) ) +
theme_minimal() +
theme( legend.position = "top",
axis.text.x = element_blank() ) +
guides( color = guide_legend( title = "Relationship Model: " ) )
print( knowledgePlot )
# ================================================================== #
# PAPER TITLE
# ================================================================== #
# This syntax file assess model fit for models estimated
# in the trust-culture-heterogeneity-analysis.R file
# ================================================================== #
# Setup ----
# Clear the workspace
rm( list = ls() )
# Load the libraries used
library( CCTpack )  # for the cultural consensus models
library( here )     # for calling local directory
library( dplyr )    # for working with the data
library( reshape2 ) # for reworking the data
library( ggplot2 )  # for plotting the agreement matrix
# ================================================================== #
# Load the estimated models ----
## 1 model (no item difficulty)
# load the object and set the name
trust.fit.1 <- load( here( "trust-culture-rodeo/trust.fit.1.Rdata" ) )
trust.fit.1 <- cctfit
cctppc( trust.fit.1 )
# load the object and set the name
trust.fit.2 <- load( here( "trust-culture-rodeo/trust.fit.2.Rdata" ) )
trust.fit.2 <- cctfit
cctppc( trust.fit.2 )
# load the object and set the name
trust.fit.3 <- load( here( "trust-culture-rodeo/trust.fit.3.Rdata" ) )
trust.fit.3 <- cctfit
cctppc( trust.fit.3 )
# load the object and set the name
trust.fit.4 <- load( here( "trust-culture-rodeo/trust.fit.4.Rdata" ) )
trust.fit.4 <- cctfit
cctppc( trust.fit.4 )
# load the object and set the name
trust.fit.5 <- load( here( "trust-culture-rodeo/trust.fit.4.Rdata" ) )
trust.fit.5 <- cctfit
cctppc( trust.fit.5 )
